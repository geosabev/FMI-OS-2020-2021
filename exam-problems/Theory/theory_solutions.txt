УСЛОВИЯ НА ЗАДАЧИТЕ ОТ СБОРНИКА И ПРИМЕРНИ МОИ РЕШЕНИЯ КЪМ ТЯХ (Теория)
- ОС - летен семестър, 2020/2021 г., СИ, Георги Събев

00. (от лекция) Всеки от процесите P и Q изпълнява поредица от две инструкции:
process P	process Q
p_1		q_1
p_2		q_2
Осигурете чрез семафори синхронизация на P и Q така, че инструкция p1 да се изпълни преди изпълнението на q2.
- Използваме семафора t1 и го инициализираме така:
semaphore t1
t1.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
p1		q1
t1.signal()	t1.wait()
p2		q2

00. (от лекция - т.нар. "Rendezvous") Всеки от процесите P и Q изпълнява поредица от две инструкции:
process P	process Q
p_1		q_1
p_2		q_2
Осигурете чрез семафори синхронизация на P и Q така, че инструкция p1 да се изпълни преди изпълнението на q2 и q1 да се изпълни преди изпълнението на p2.
- Използваме семафорите t1 и t2 и ги инициализираме така:
semaphore t1, t2
t1.init(0)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
p1		q1
t1.signal()	t2.signal()
t2.wait()	t1.wait()
p2		q2

66. (2016-SE-01) Всеки от процесите P и Q изпълнява поредица от три инструкции:
process P	process Q
p_1		q_1
p_2 		q_2
p_3 		q_3
Осигурете чрез семафори синхронизация на P и Q така, че инструкция p1 да се изпълни преди q2, а q2 да се изпълни преди p3.
- Използваме семафорите t1 и t2 и ги инициализираме така:
semaphore t1, t2
t1.init(0)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
p1		q1
t1.signal()	t1.wait()
p2		q2
t2.wait()	t2.signal()
p3		q3

67. (2016-SE-02) Опишете накратко основните процедури и структури данни, необходими за реализация на семафор.
Каква е разликата между слаб и силен семафор?
Опишете максимално несправедлива ситуация, която може да се получи в избирателна секция, ако на входа на секцията пазач – член на изборната комисия пуска гласоподавателите вътре така:
(1) във всеки момент в секцията може да има най-много двама гласоподаватели.
(2) пазачът работи като слаб семафор.
- Структурите от данни, необходими за реализацията на семафор са две:
Брояч cnt, в който се пази броят на процесите, които могат да бъдат допуснати до ресурса, охраняван от семафора, и контейнер Q, в който се пази информация
кои процеси чакат достъп до ресурса.

Процедурите, необходими за реализацията на семафор са три:
Конструктор Init(c0:integer), който задава начална стойност на брояча cnt, а контейнерът Q се инициализира да е празен.
Метод Wait(), който се използва при опит за достъп до ресурса (заемане на ресурса). Броячът се намалява с 1 и ако стане отрицателен, процесът,
викащ Wait() се блокира, а номерът му се вкарва в контейнера Q.
Метод Signal(), който се ползва при завършване на достъпа до ресурса (освобождаване на ресурса). Броячът се увеличава с 1 и ако Q не е празен,
един от процесите в него се вади и активира.

Един семафор е силен, когато контейнерът Q е реализиран като обикновена опашка - винаги активираме процеса, блокиран най-рано.
Един семафор е слаб, когато контейнерът Q не е реализиран като обикновена опашка - при изпълнение на Signal() активираме процес, който може да не е първи в списъка на чакащите.

Ако пазачът на входа на избирателната секция действа като слаб семафор, може да се получи следната неприятна ситуация:
Първите двама гласоподаватели влизат в секцията, пристига трети гласоподавател (неприятел на пазача) и чака. След него започват да пристигат приятели на пазача и
той ги пуска с предимство. Може да се стигне дотам, че третият гласоподавател да чака цял ден и да гласува последен.

68. (2017-SE-01) Всеки от процесите P, Q и R изпълнява поредица от три инструкции:
process P	process Q	process R
p_1 		q_1 		r_1
p_2 		q_2 		r_2
p_3 		q_3 		r_3
Осигурете чрез семафори синхронизация на P, Q и R така, че инструкция p1 да се изпълни преди q2 и r2.
Забележка: Решения на задачата с повече от един семафор носят не повече от 20 точки.
- Използваме семафора t и го инициализираме така:
semaphore t
t.init(0)

Добавяме в кода на процесите P, Q и R синхронизиращи инструкции:
process P	process Q	process R
p_1		q_1		r_1
t.signal()	t.wait()	t.wait()
p_2 		t.signal()	t.signal()
p_3		q_2 		r_2
 		q_3 		r_3

69. (2017-SE-02) Преди стартиране на процеси P и Q са инициализирани два семафора и брояч:
semaphore e, m
e.init(1); m.init(1)
int cnt = 0

Паралелно работещи няколко копия на всеки от процесите P и Q изпълняват поредица от инструкции:
process P 		process Q
m.wait() 		e.wait()
 cnt=cnt+1 		 q_section
 if cnt=1 e.wait() 	e.signal()
m.signal()

p_section

m.wait()
 cnt=cnt-1
 if cnt=0 e.signal()
m.signal()

Дайте обоснован отговор на следните въпроси:
а) Могат ли едновременно да се изпълняват инструкциите psection и qsection?
б) Могат ли едновременно да се изпълняват няколко инструкции psection?
в) Могат ли едновременно да се изпълняват няколко инструкции qsection?
г) Има ли условия за deadlock или starvation за някой от процесите?
Упътване:
Ще казваме, че P е в критична секция, когато изпълнява инструкцията си psection. Същото за Q, когато изпълнява qsection.
Изяснете смисъла на брояча cnt и какви процеси могат да бъдат приспани в опашките на двата семафора.
Покажете, че в опашката на семафора e има най-много едно копие на P и произволен брой копия на Q.
Покажете, че в момента на изпълнение на e.signal() в кой да е от процесите, никой процес не е в критичната си секция.
- Първо забелязаме, че семафорът m се ползва само от P в ролята на mutex. В неговата опашка може да има само копия на P и само едно работещо копие може да намалява/увеличава брояча
синхронизирано с блокирането/освобождаването на семафора e. Увеличаването на cnt става преди критичната секция на P, а намалянето след нея. Ако не вървят никакви копия на Q,
лесно се убеждаваме, че могат да се изпълняват произволен брой критични секции на P, като броячът съвпада с броя на паралелно изпълняваните критични секции.
Така отговорът на въпрос (б) е ДА.

Заемането на семафора e в P става точно когато cnt променя стойността си от 0 в 1. Освобождаването става точно когато cnt променя стойността си от 1 в 0.
Тъй като при инициализацията броячът на e е 1, а употребата му и в двата вида процеси започва със заемане и завършва с освобождаване, само едно копие от двата типа ще може да
премине e.wait(). Разглеждаме два случая:
(A) Процесът Q преминава. Тогава ще се изпълни критичната му секция, но само от това копие. Останалите копия на Q ще бъдат приспани от първата си инструкция. Следователно
отговорът на въпрос (в) е НЕ.
Ако версия на P пробва e.wait(), тя също ще бъде приспана. Това ще стане точно когато cnt променя стойността си от 0 в 1, тоест не се изпълняват критични секции на P. В момента
на приспиване и мутекса m е блокиран. Това обстоятелство ще блокира всички опити на други копия на P да преминат m. В този случай в опашката на семафора e има точно едно копие на P.
(B) Процесът P преминава. Ще започне изпълнение на неговата критична секция и евентуално на други копия на P, докато cnt>0. През този период всички копия на Q ще бъдат приспани
от първата си инструкция. Когато cnt намалее до 0, никое копие не изпълнява критична секция.
От двата разгледани случая следва, че в един момент могат да се изпълняват няколко критични секции на P или една критична секция на Q. Следователно отговорът на въпрос (а) е НЕ.
В описаната схема няма условия за deadlock. Q не може да инициира deadlock, тъй като ползва само един ресурс. P също не може поради реда на заемане на ресурсите (първо заема
семафора m, после e).

В описаната схема има условия за гладуване (starvation) на процес Q. Нека критичната секция на P се изпълнява бавно и Q започва работа след P. Ще започне изпълнение на критична
секция на P и ако постоянно започват работа нови копия, броячът cnt може да остане положителен неограничено време. Така Q ще бъде приспан неограничено дълго.

70. (2017-SE-03) Няколко копия на процеса P изпълняват поредица от три инструкции:
process P
p_1
p_2
p_3
a) Осигурете чрез семафор синхронизация на копията така, че най-много един процес да изпълнява инструкция p2 във всеки един момент.
б) Опишете разликата при реализация на слаб и силен семафор.
в) Възможно ли е в зависимост от начина на реализация на семафора в подусловие а) да настъпят условия за deadlock или starvation? Ако да, опишете сценарий за поява на неприятната ситуация.
- а) Използваме семафора t и го инициализираме така:
semaphore t
t.init(1)

Добавяме в кода на процеса P синхронизиращи инструкции:
process P
p_1
t.wait()
p_2
t.signal()
p_3

б) При реализацията на силен семафор контейнерът Q е обикновена опашка - винаги активираме процеса, блокиран най-рано.
При реализацията на слаб семафор контейнерът Q не е реализиран като обикновена опашка - при изпълнение на Signal() активираме процес, който може да не е първи в списъка на чакащите.

в) Възможно е настъпване на условия за starvation. При реализиран слаб семафор, е възможно следното: Първото копие на процеса P започва изпълнение на инструкциите си. Изпълнява се p_1,
броячът на t става равен на 0, като през това време няколко нови копия на процеса P започват изпълнение на своите инструкции и биват приспани, тъй като броячът става по-малък от 0.
Ако семафорът t е слаб, е възможно първото събудено копие на P да не бъде първото, влезнало в опашката на контейнера Q на семафора - т.е. да не се спазва правилната последователност на
изпълнение на копията. 

71. (2017-SE-04) Всеки от процесите P и Q изпълнява поредица от две инструкции:
process P 	process Q
p_1 		q_1
p_2 		q_2
Осигурете чрез семафори синхронизация на P и Q, така че инструкция p1 да се изпълни преди q2, а q1 да се изпълни преди p2.
- Тук имамe пример за среша във времето (rendevous). Използваме семафорите t1 и t2 и ги инициализираме така:
semaphore t1, t2
t1.init(0)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
p1		q1
t1.signal()	t2.signal()
t2.wait()	t1.wait()
p2		q2

72. (2017-SE-05) Всеки от процесите P и Q изпълнява поредица от три инструкции:
process P 	process Q
p_1 		q_1
p_2 		q_2
p_3 		q_3
Осигурете чрез два семафора синхронизация на P и Q така, че отделните инструкции да се изпълнят в следния времеви ред: p1, q1, p2, q2, p3, q3.
- Използваме семафорите t1 и t2 и ги инициализираме така:
semaphore t1, t2
t1.init(0)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
p1		t2.wait()
t2.signal()	q1
t1.wait()	t1.signal()
p2		t2.wait()
t2.signal()	q2
t1.wait()	t1.signal()
p3		t2.wait()
t2.signal()	q3

73. (2017-SE-06) Да приемем, че в съвременната операционна система процесът има 4 състояния:
• R – работещ (running, използва CPU)
• A – активен (ready, очаква CPU)
• S – блокиран (sleeping, очаква вход/изход)
• T – изчакващ време (sleeping, очаква времеви момент)
Нарисувайте диаграма на състоянията и преходите между тях. Диаграмата е ориентиран граф с върхове отделните състояния и ребра – възможните преходи.
Опишете накратко събитията, предизвикващи преход по всяко ребро на графа.
- 

74. (2017-SE-07) Процесът P създава тръба (pipe) с извикване на функцията pipe(int pipefd[2]) в ОС GNU/Linux.
а) Кои процеси не могат да ползват тръбата?
б) Опишете друг метод за изграждане на комуникационен канал, който дава възможност на произволни процеси да изградят и ползват канала.
Допълнително искаме новоизградения канал да е достъпен само за процесите, които са го създали.
Упътване: Прочетете man-страницата за функцията pipe().
- (а) Тръбата е достъпна само чрез файловите дескриптори pipefd[0] и pipefd[1]. Те са видими само за процеса P и неговите наследници.
Процесите, които не са наследници на P, не могат да ползват тръбата.

(б) За да бъде използван от произволен процес в изчислителната среда, комуникационният канал трябва да бъде видим (адресуем, именуван). В повечето UNIX системи има възможност за създаване
на именувана тръба (FIFO), тя обаче се създава от един процес и е достъпна за всички останали, тоест нарушава допълнителното условие на т. (б). Друг вариант е един процес да създаде
именуван обект, който да послужи като адрес при изграждането на връзка от друг процес. Използваната абстракция се нарича socket.
Сокетът се дефинира като единия край на комуникационен канал.

Един процес, наричан обичайно сървер, изпълнява следната поредица:
sfd=socket(domain, type, protocol); // създава socket
bind(sfd, &my_addr, addrlen); // присвоява име на socketa
listen(sfd, backlog); // започва приемане на заявки за връзки
cfd = accept(sfd, &peer_addr, addrlen); // приема заяка за изграждане на връзка

Друг процес, наричан обичайно клиент, изпълнява следната поредица:
fd=socket(domain, type, protocol); // създава socket
connect(fd, &server_addr, addrlen); // подава заяка за изграждане на връзка

Сърверът създава сокета sfd и му дава име чрез bind. Извикването listen активира процеса на изграждане на връзки. Клиентът създава сокета fd, без да е нужно да го именува.
Извикването connect е заявка за изграждане на връзка към именувания сокет sfd. Сърверът приема заявката на клиента чрез accept. Изградената връзка е между файловите дескриптори cfd на
сървера и fd на клиента. Те ги ползват за обмен на информация. Файловият дескриптор sfd на сървера продължава да приема нови заявки от клиенти. Благодарение на присвоеното му име
sfd дава възможност на другите процеси да се свържат със сървера. Името на sfd определя какви клиенти могат да ползват сървера. Ако то е име в интернет (IP адрес, порт), всички процеси,
изпълнявани на компютри, имащи достъп до интернет, могат да се свържат към сървера.

75. (2017-SE-08) Множество паралелно работещи копия на всеки от процесите P и Q изпълняват поредица от две инструкции:
process P 	process Q
p_1 		q_1
p_2 		q_2
Осигурете чрез семафори синхронизация на работещите копия, така че:
а) В произволен момент от времето да работи най-много едно от копията.
б) Работещите копия да се редуват във времето – след изпълнение на копие на P да следва изпълнение на копие на Q и обратно.
в) Първоначално е разрешено да се изпълни копие на P.
- Използваме семафорите t1 и t2 и ги инициализираме така:
semaphore t1, t2
t1.init(1)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
t1.wait()	t2.wait()
p1		q1
p2		q2
t2.signal()	t1.signal()

76. (2018-CS-01) Всеки от процесите P, Q и R изпълнява поредица от три инструкции:
process P 	process Q 	process R
p_1 		q_1 		r_1
p_2 		q_2 		r_2
p_3 		q_3 		r_3
Осигурете чрез семафори синхронизация на P, Q и R така, че да се изпълнят едновременно следните изисквания:
• Инструкция p1 да се изпълни преди q2 и r2
• Инструкция r2 да се изпълни преди p3.
Забележка: Решение с 2 семафора ще бъде оценено с 30 точки, решение с повече семафори ще ви донесе 20 точки.
- Използваме семафорите t1 и t2 ги инициализираме така:
semaphore t1, t2
t1.init(0)
t2.init(0)

Добавяме в кода на процесите P, Q и R синхронизиращи инструкции:
process P	process Q	process R
p1		q1		r1
t1.signal()	t1.wait()	t1.wait()
p2		q2		r2
t2.wait()	t1.signal()	t1.signal()
p3		q3		t2.signal()
				r3

77. (2018-CS-02) Всеки от процесите P, Q и R изпълнява поредица от три инструкции:
process P 	process Q 	process R
p_1 		q_1 		r_1
p_2 		q_2 		r_2
p_3 		q_3 		r_3
Осигурете чрез семафори синхронизация на P, Q и R така, че да се изпълнят едновременно следните изисквания:
• Инструкция p1 да се изпълни преди q2
• Инструкция q1 да се изпълни преди r2
• Инструкция r1 да се изпълни преди p2
• Инструкция r3 да се изпълни след p2 и q2.
- Използваме семафорите t1, t2 и t3 и ги инициализираме така:
sempahore t1, t2, t3
t1.init(0)
t2.init(0)
t3.init(0)

Добавяме в кода на процесите P, Q и R синхронизиращи инструкции:
process P	process Q	process R
p1		q1		r1
t1.signal()	t1.wait()	t2.wait()
t3.wait()	t2.signal()	t3.signal()
p2		q2		r2
t1.signal()	t2.signal()	t1.wait()
p3		q3		t2.wait()
				r3

78. (2018-CS-03) При споделено ползване на памет от няколко процеса е възможно да настъпи надпревара за ресурси (race condition).
(а – 10 точки) Дефинирайте понятието race condition.
(б – 05 точки) Възможно ли е да настъпи race condition в еднопроцесорна система? Ако да, при какви условия.
(в – 15 точки) Какви инструменти ползваме, за да избегнем race condition?
- а) Race condition, буквално може да се преведе "борба за ресурси" е състояние, което настъпва когато два или повече процеса едновременно се опитат да достъпят данен споделен ресурс,
като започва надпревара за това кой процес ще достъпи паметта първи. Това може да доведе до проблем, тъй като не само, че не знаем кой процес ще изпълни съответната "критична част" първи,
ами и ако например споделения ресурс е дадена променлива и единия от процесите изпълнява следния код: if (cnt==0) cnt=1;
Възможно е между проверката и присвояването на новата стойност друг процес да достъпи споделения ресурс, при което е възможно да настъпи проблем и в двата процеса.

б) Да, възможно е, тъй като в даден момент се изпълнява само 1 процес ние не знаем в какъв ред системата ще даде право на процесите да се изпълняват.
Въпреки, че системата е еднопроцесорна, тя може да поддържа няколко нишки на един и същи, или различни процеси. Възможно е една от нишките да зависи от някакъв общ ресурс,
който обаче в някакъв друг момент да се използва от друг процес и той да го променя.

в) Най-простият инструмент за избягване на race-condition e spinlock. Това е инструмент на най-ниско ниво който на практика ни дава възможност да "заключим" достъпа до даден ресурс,
когато го използваме ние, и да го "отключим" в последствие, когато вече не го използваме. Това става с наличието на един допълнителен бит, който ни указва дали ресурса е свободен за
използване, или не е. Това обаче не е достатъчно, тъй като ако даден процес се извика рекурсивно, то всеки следващ процес ще зацикли и бита никога няма да се освободи, т.е. паметта
ще остане винаги заключена, т.нар. deadlock. Освен този бит, е важно да се забранят прекъсванията, така че да не може да се стигне до зацикляне.
Друг начин за избягване на race condition са семафорите.

79. (2018-CS-04) Една от класическите задачи за синхронизация се нарича Задача за читателите и писателите (Readers-writers problem).
а) (10 точки) Опишете условието на задачата.
б) (20 точки) Опишете решение, използващо семафори.
- а) Задачата за читателите и писателите се изразява в следното: Имаме стая, в която читатели могат да влизат да четат, а писатели да пишат. Искаме да синхронизираме операциите
за четене и писане по следния начин:
 Ако в стаята има писател, то никой друг не трябва да има достъп до стаята.
 В стаята може да има произволен брой читатели.
 Не трябва да има условие за deadlock.
 Не трябва да има условие за starvation на някой от писателите/читателите.

б) Идеята на решението на задачата е следната: Когато първият читател се опита да влезе в стаята (под стая разбираме критична секция), той трябва да провери дали е празна,
след което всеки следващ читател е необходимо да проверява само дали в стаята има поне един читател. Възможно е обсче писателите да гладуват, заради наличието на много на брой читатели
или бавни такива. Затова използваме бариера, която ще спира читатели да навлизат, при условие, че има поне един писател, който чака да влезе в критичната секция. 

barrier.init(1);
mutex.init(1);
roomEmpty.init(1);
cnt=0

Readers					Writers
barrier.wait()				barrier.wait()
barrier.signal()
mutex.wait()				roomEmpty.wait()
 cnt=cnt+1				
 if(cnt==1) roomEmpty.wait()
mutex.signal()

READ					WRITE

mutex.wait()
 cnt=cnt+1
 if (cnt==0) roomEmpty.signal()		roomEmpty.signal()
mutex.signal()				barrier.signal()

Ако стаята е празна, първият читател влиза. След него могат да влязат произволен брой читатели, тъй като бариерата е с първоначална стойност 1 и ако не е дошъл писател, всеки следващ
читател сигнализира, че бариерата може да се премине. Ако дойде писател, той може да премине бариерата, тъй като тя е отворена, но я затваря след себе си. Така никой следващ читател не
може да премине бариерата. Тук писателят изчаква докато читателите в стаята не приключат работата си. Когато стаята се изпразни, последният читател сигнализира и писателят може да влезе.
Когато той приключи, отваря бариерата и читателите/писателят на опашката могат да влязат.

80. (2018-CS-05) Какви са възможните състояния на процес. Нарисувайте диаграма на състоянията и преходите между тях. Опишете накратко ситуациите, предизвикващи преходи между състояния.
- Основните състояния на процесите са: Running, Sleeping, Stopped и Zombie
Running са процесите, които активно се нуждаят и използват ядро и процесор, който изчислява. Това са процеси, които от гледна точка на потребителя имат работа за вършене.
Те може да се изчакват и редуват, ако не стигат процесорите, но като цяло имат нужда от изчислителна мощ.

Sleeping (спящите) процеси от гледна точка на потребителя са работещи програми, които са стигнали в състояние, при което нямат нужда да изчисляват нещо докато не настъпят интересни за тях
събития в системата. Те са в комуникация с друг процес или устройство и очакват да им се подадат данни, но очакваните процеси нямат готовност да им подадат
(например поради запушен комуникационен канал или поради бавна работа на другата страна и т.н.).
Приспани могат да бъдат процеси, чакащи някое от следните: I/O – извършване на входно изходни операции, конкретен времеви момент, сигнал от друг процес за промяна на състоянието му.

Stopped (спрян) процесът не представлява интерес нито за потребителите, нито за операционната система.

Zombie процесът е процес, при който е започнало спирането, но не е завършило (пускането и спирането на процес са бавни и многостъпкови събития)

81. (2018-SE-01) Всеки от процесите P, Q и R изпълнява поредица от три инструкции:
process P 	process Q 	process R
p_1 		q_1 		r_1
p_2 		q_2 		r_2
p_3 		q_3 		r_3
Осигурете чрез семафори синхронизация на P, Q и R така, че да се изпълнят едновременно следните изисквания:
• Някоя от инструкциите p2 и q2 да се изпълни преди r2.
• Ако инструкция p2 се изпълни преди r2, то q2 да се изпълни след r2.
• Ако инструкция q2 се изпълни преди r2, то p2 да се изпълни след r2.
Забележка: Решение с 2 семафора ще бъде оценено с 30 точки, решение с повече семафори ще ви донесе 20 точки.
- Използваме семафорите t1 и t2 и ги инициализираме така:
sempahore t1, t2
t1.init(1)
t2.init(0)

Добавяме в кода на процесите P, Q и R синхронизиращи инструкции:
process P	process Q	process R
p1		q1		r1
t1.wait()	t1.wait()	t2.wait()
p2		q2		r2
t2.signal()	t2.signal()	t1.signal()
p3		q3		r3

82. (2018-SE-02) Дадена е програма за ОС Linux, написана на езика C:
#include <unistd.h>
#include <stdio.h>

int main(void)
{
	int p1, p2;
	p1=fork();
	p2=fork();
	printf("Hello world!\n");
}
а) Колко пъти ще се отпечата текста "Hello world!" при изпълнението на програмата? Обосновете отговора си.
б) Как работи системното извикване fork()?
в) Нарисувайте кореновото дърво с върхове процесите, които ще се стартират в резултат от изпълнението на програмата и ребра двойките родител-наследник.
- a) Текстът ще се отпечата 4 пъти, тъй като p1=fork(); ще създаде копие на текущия процес. След това всяка инструкция се изпълнява от двата процеса - баща и наследник (дете).
Командата p2=fork() ще бъде изпълнена от всеки от процесите, при което ще бъдат създадени две нови копия - дете на процесът баща и дете на процесът дете. Всички четири процеса продължават
да вървят по кода, т.е. командата printf("Hello world!\n"); ще бъде изпълнена от всички тях - 4 пъти.

б) fork() създава нов процес - копие на текущия, като процесът, извикал fork, се нарича процес-баща, а новосъздаденият процес - процес-дете. Процесът-дете е копие на бащата,
с изключение на няколко разлики: бащата и детето имат различни processID's, PPID на детето е равен на PID-a на бащата. Детето не наследява от баща си семафори, I/O операции,
чакащи сигнали, таймери, memory locks и record locks. Детето наследява копие на всички файлови дескриптори.
При успешно завършване fork() връща PID на детето, което е създадено. При неуспех връща -1.

в) Основният процес - P0, резултат от първия fork() - P1 {P0, P1}, резултат от втория fork() - P2 {P0, P1} и P3 {P1, P3}
          P0
         /  \
        P1  P2
       /
      P3

83. (2018-SE-03) Множество паралелно работещи копия на всеки от процесите P и Q изпълняват поредица от три инструкции:
process P 	process Q
p_1 		q_1
p_2 		q_2
p_3 		q_3
Осигурете чрез семафори синхронизация на работещите копия, така че три инструкции – p1, q2 и p3 се редуват циклично:
• първа се изпълнява инструкция p1 на някое от работещите копия на процес P;
• след завършването ѝ се изпълнява инструкция q2 на някое копие на Q;
• след нея – p3 на някое копие на P;
• с това едно минаване през цикъла завършва и отново може да се изпълни инструкция p на някое от работещите копия на процес P.
- Използваме семафорите t1, t2 и t3 и ги инициализираме така:
sempahore t1, t2, t3
t1.init(1)
t2.init(0)
t3.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
t1.wait()	q1
p1		t2.wait()
t2.signal()	q2
p2		t3.signal()
t3.wait()	q3
p3
t1.signal()

84. (2018-SE-04) Опишете накратко кои системни извиквания изграждат стандартните комуникационни канали в UNIX – неименувана тръба (pipe), връзка процес-файл,
двустранна връзка процес-процес (connection).
-

85. (2018-SE-05) Опишете какви изисквания удовлетворява съвременна файлова система, реализирана върху блоково устройство (block device).
Опишете накратко реализацията и целта на следните инструменти:
а) отлагане на записа, алгоритъм на асансьора;
б) поддържане на журнал на файловата система.
- Реализация на файлова система:
Твърд диск – това е диск разделен на много „пътечки“:
 Над повърхнината има електрическо устройство, което засича дали бита е 1 или 0;
 Придвижването на главата на това устройство от една пътечка на друга е механично и става бавно;
 Всяка пътечка е разделена на няколко сектора от по 512 или 1024 байта;
 Главата не се допира до диска, а лети много малко над повърхността;
 Софтуера знае колко е голям сектора и колко е времето за преминаване от един до друг сектор;
 Файла се представя като много сектори;
 Не са последователно разпределени байтовете на файловете, защото така не могат лесно да нарастват;
 Файлът се разполага там където може, процесът на разхвърляне се нарича фрагментация.

Алгоритъм на асансьора:
 Разместват се така заявките към четене и писане, че главата да изминава минимално разстояние;
 Има две приоритетни опашки: едната се състои от файове, които се намират по посока на движението на главата, а другата от файове, които се намират в обратната посока;
 Ако е празна главата на опашката по посока на главата на устройството, то се сменя посоката.

Aлгоритъмът на асансьора поражда проблем за надеждността (внезапно спиране на тока). За да се справим с този проблем съществуват така наречените журнали (лог файлове).
Записваме промените във файл, който се нарича журнал, в него се запазва пълната информация за операциите над файлове и когато се позапълни/препълни журнала,
спираме и отразяваме операциите от журнала над файловете, ако спре тока журнала ще пази последните промени, а файловете ще са си консистентни. Четат се първо старите файлове и се
проверява дали в журнала са променени, ако спре тока, докато пишем операцията/транзакцията, тя няма да се е изтрила преди да е завършила и затова ще я пазим все още в журнала.
Във файловите системи транзакцията е елементарна файлова операция (read, write, open). Журналът (лог файла) се намира или в друг диск или в друг дисков дял,
за да може двете паралелно да работят, но в персоналните устройства журналът е файл в самата файлова система или в същия дял.

Две фази:
1. Файловите операции в истинския ред по време се записват в журнала;
2. Когато се натрупат се подават заявките на алгоритъма на асансьора.

86. (2019-CS-01) При реализация на файлова система върху твърд диск файловете и директориите се записват върху сектори от диска.
Времето за достъп до секторите зависи от текущото положение на механичните компоненти на диска – над коя пътечка е главата за четене/запис и каква е позицията й над пътечката.
Защо се прави разместване във времето на операциите по четене и запис върху диска?
Опишете накратко реализацията и целта на алгоритъма на асансьора.
- Алгоритъмът на асансьора се изразява в следното:
Разместват се така заявките към четене и писане, че главата да изминава минимално разстояние;
Има две приоритетни опашки: едната се състои от файове, които се намират по посока на движението на главата, а другата от файове, които се намират в обратната посока;
Ако е празна главата на опашката по посока на главата на устройството, то се сменя посоката.

87. (2019-CS-02) Дадена е програма за ОС Linux, написана на езика C:
#include <unistd.h>
#include <stdio.h>
int main(void)
{	
	int p1, p2, p3;
	p1=fork();
	if (p1==0) {
		p2=fork();
		if (p2>0) p3=fork();
	}
	printf("Hello world!\n");
}
а) Колко пъти ще се отпечата текста Hello world! при изпълнението на програмата? Обосновете отговора си.
б) Как работи системното извикване fork()?
в) Нарисувайте кореновото дърво с върхове процесите, които ще се стартират в резултат от изпълнението на програмата и ребра двойките родител-наследник.
- а) Текстът ще се отпечата 4 пъти, тъй като p1=fork(); ще създаде копие на текущия процес. Сега останалата част от програмата се изпълнява от два процеса.
В случая, в който се намираме в процеса-наследник p1 има стойност 0, а когато сме в процеса-баща - стойност по-голяма от 0. Следователно само единият процес ще влезне в тялото на if-a.
Другият ще изпълни командата printf("Hello world!\n");. Процесът, влезнал в тялото на if-a, ще изпълни p2=fork(), при което ще се създаде негово копие. Сега за стария процес стойността 
на p2 е по-голяма от 0, а за новия процес - равна на 0. Отново само единият от двата процеса ще влезне в тялото на if-a, а другият ще излезне от if-a и ще изпълни командата
printf("Hello world!\n");. Другият процес ще изпълни p3=fork(), при който ще бъде създадено негово копие. Двата процеса ще излязат от тялото на if и ще изпълят printf("Hello world!\n");
Следователно командата printf("Hello world!\n"); ще бъде изпълнена общо 4 пъти.

б) fork() създава нов процес - копие на текущия, като процесът, извикал fork, се нарича процес-баща, а новосъздаденият процес - процес-дете. Процесът-дете е копие на бащата,
с изключение на няколко разлики: бащата и детето имат различни processID's, PPID на детето е равен на PID-a на бащата. Детето не наследява от баща си семафори, I/O операции,
чакащи сигнали, таймери, memory locks и record locks. Детето наследява копие на всички файлови дескриптори.
При успешно завършване fork() връща PID на детето, което е създадено. При неуспех връща -1.

в) Основният процес - P0, резултат от p1=fork() - P1 {P0, P1}, резултат от p2=fork() - P2 {P1, P2}, резултат от p3=fork() - P3 {P1, P3}
          P0
         /
        P1
       /  \
      P2  P3

88. (2019-CS-03) Опишете как се изгражда комуникационен канал (connection) между процес-сървер и процес-клиент със следните системни извиквания в стандарта POSIX:
socket(), bind(), connect(), listen(), accept()
-

89. (2019-CS-04) Опишете накратко основните комуникационни канали в ОС Linux. Кои канали използват пространството на имената и кои не го правят?
- Основните комуникационни канали в ОС Linux са тръба (pipe), именувана тръба (fifo), връзка процес-файл и конекция (изградена с механизма socket). Всички освен обикновената тръба
използват пространството на имената. Операциите за ползване на канала са общи - read(...), write(...) и close(...). Специфични са изискванията за изграждане на различните видове канали.

90. (2019-SE-01) Всеки от процесите P, Q и R изпълнява поредица от три инструкции:
process P 	process Q
p_1 		q_1
p_2 		q_2
p_3 		q_3
Осигурете чрез два семафора синхронизация на P и Q така, че да са изпълнени едновременно следните времеви зависимости:
• Инструкция p1 да се изпълни преди q2
• Инструкция q2 да се изпълни преди p3
• Инструкция q1 да се изпълни преди p2
• Инструкция p2 да се изпълни преди q3.
Забележка: За решение с повече семафори ще получите 20 точки.
- Използваме семафорите t1 и t2 и ги инициализираме така:
sempahore t1, t2
t1.init(0)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
p1		q1
t1.signal()	t2.signal()
t2.wait()	t1.wait()
p2		q2
t1.signal()	t2.signal()
t2.wait()	t1.wait()
p3		q3

91. (2019-SE-02) Множество паралелно работещи копия на всеки от процесите P и Q изпълняват поредица от две инструкции:
process P 	process Q
p_1 		q_1
p_2 		q_2
Осигурете чрез семафори синхронизация на работещите копия, така че да са изпълнени едновременно следните условия:
• В произволен момент от времето да работи най-много едно от копията.
• Работещите копия да се редуват във времето – след изпълнение на копие на P да следва изпълнение на копие на Q и обратно.
• Първоначално е разрешено да се изпълни копие на P.
- Използваме семафорите t1 и t2 и ги инициализираме така:
semaphore t1, t2
t1.init(1)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
t1.wait()	t2.wait()
p1		q1
p2		q2
t2.signal()	t1.signal()

92. (2019-SE-03) Процесите P и Q се изпълняват паралелно. Споделената променлива A има начална стойност 4. Променливата R е локална за двата процеса.
process P 	process Q
R=A 		R=A
R=R+3 		R=R+2
A=R 		A=R
Каква е стойността на A след изпълнението на процесите? Дайте обоснован отговор.
- 

93. (2019-SE-04) Опишете разликата между синхронни и асинхронни входно-изходни операции. Дайте примери за програми, при които се налага използването на асинхронен вход-изход.
- При синхронна входно-изходна операция системното извикване може да доведе до приспиване (блокиране) на потребителския процес, поръчал операцията.
Същевременно, при нормално завършване, потребителският процес разчита на коректно комлектоване на операцията – четене/запис на всички предоставени/поръчани данни във/от входно-изходния
канал, или цялостно изпълнение на друг вид операция (примерно, изграждане на TCP връзка).
При асинхронна входно-изходна операция системното извикване не приспива (не блокира) потребителския процес, поръчал операцията. Същевременно, при невъзможност да се комплектова операцията,
ядрото връща управлението на процеса със специфичен код на грешка и друга информация, която служи за определяне на степента на завършеност на операцията.
Потребителският процес трябва да анализира ситуацията и при нужда да направи ново системно повикване по-късно, с цел да довърши операцията. Използването на асинхронни операции позволява
на един процес да извършва паралелна комуникация по няколко канала с различни устройства или процеси, без да бъде блокиран в случай на липса на входни данни, препълване на буфер за
изходни данни или друга ситуация, водеща до блокиране.
Примери:
(1) Когато ползваме WEB-browser, той трябва да реагира на входни данни от клавиатура и мишка, както и на данните, постъпващи от интернет, т.е. на поне 3 входни канала.
Браусерът проверява чрез асинхронни опити за четене по кой от каналите постъпва информация и реагира адекватно.
(2) Сървер в интернет може да обслужва много на брой клиентски програми, като поддържа отворени TCP връзки към всяка от тях. За да обслужва паралелно клиентите, сърверът трябва
да ползва асинхронни операции, за да следи по кои връзки протича информация и кои са пасивни. Когато програмата ползва асинхронни операции и никой от входно-изходните
канали не е готов за обмен на данни, тя има нужда от специален механизъм за предоствяне на изчислителния ресурс на останалите процеси. Обикновено в такива случаи програмата се приспива
сама за кратък период от време (в UNIX това става с извикване на sleep(), usleep() или nanosleep()).

94. (2019-SE-05) Множество паралелно работещи копия на процеса P изпълняват поредица от две инструкции:
process P
p_1
p_2
Осигурете чрез семафори синхронизация на работещите копия, така че:
• Инструкцията p2 на всяко от работещите копия да се изпълни след като инструкция p1 е завършила изпълнението си в поне 3 работещи копия.
Упътване: Освен семафори, ползвайте и брояч.
- Използваме брояч cnt и два семафора – m1 и m2 и ги инициализираме така:
semaphore m1, m2
m1.init(1)
m2.init(0)
int cnt=0

Добавяме в кода на процеса P синхронизиращи инструкции:
process P	
p_1
m1.wait()
 cnt=cnt+1
 if cnt=3 m2.signal()
m1.signal()
m2.wait()
p_2

95. (2019-SE-06) Опишете реализацията на комуникационна тръба (pipe) чрез семафори. Предполагаме, че тръбата може да съхранява до n байта, подредени в обикновена опашка.
Тръбата се ползва от няколко паралелно работещи изпращачи/получатели на байтове. Процесите изпращачи слагат байтове в края на опашката, получателите четат байтове от началото на опашката.
- Необходими структури от данни:
 Опашка (или масив) Q с n елемента – тъй като е възможно да имаме бърз и бавен процес (например: единия чете бързо, а другия пише бавно) е нужно опашката да бъде по-дълга,
за да не се приспива по-бързия процес (приспиването е бавна операция, тъй като включва в себе си смяна на контекста). В началото тази опашка ще е празна;
 free_bytes - семафор, който ще индикира за свободните байтове в опашката;
 ready_bytes - семафор, който ще индикира колко байта са готови за четене (до колко е запълнена опашката);
 mutex_read – мутекс, който ще защитава критичната секция за четене;
 mutex_write - мутекс, който ще защитава критичната секция за писане.

Процесът, който чете, първоначално ще проверява дали има готови за четене байтове. Ако няма, той ще се приспи и ще чака да постъпят такива.
Ако има, той ще провери дали някое друго копие на P не чете в момента. Ако да, той отново се приспива. Ако не, той ще прочете байт и ще го запише в променливата.
След това ще сигнализира, че в опашката има още един свободен байт чрез подаване на сигнал на семафора free_bytes.

Процесът, който пише, първоначално ще провери дали има свободни байтове в опашката. Ако няма, ще се приспи и ще чака да се освободят байтове. Ако има, ще трябва
да провери дали някое друго копие на пишещ процес не пише в момента в опашката. Ако да, то отново процеса ще се приспи. Ако не, ще сложи байта си  в опашката и ще
сигнализира че още един байт е готов за четене, което се осъществява чрез подаване на сигнал на семафора ready_bytes.

96. (2020-SE-01) Множество паралелно работещи копия на всеки от процесите P и Q изпълняват поредица от три инструкции:
process P 	process Q
p_1 		q_1
p_2 		q_2
p_3 		q_3
Осигурете чрез семафори синхронизация на P и Q така, че поне една инструкция p_1 да се изпълни преди всички q_2, и поне една инструкция q_1 да се изпълни преди всички p_2.
Обосновете отговора си.
- Използваме семафорите t1 и t2 и ги инициализираме така:
sempahore t1, t2
t1.init(0)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q
p1		q1
t1.signal()	t2.signal()
t2.wait()	t1.wait()
t1.signal()	t2.signal()
p2		q2
p3		q3

97. (2020-SE-02) Множество паралелно работещи копия на всеки от процесите P, Q, R и W изпълняват поредица от две инструкции:
process P 	process Q 	process R 	process W
p_1 		q_1 		r_1	 	w_1
p_2 		q_2 		r_2 		w_2
Осигурете чрез семафори синхронизация на работещите копия така, че да са изпълнени едновременно следните условия:
а) В произволен момент от времето да работи най-много едно от копията (един-единствен процес глобално).
б) Работещите копия да се редуват във времето – първо се изпълнява копие на P или Q. След това трябва да се изпълни копие на R или W. Следва ново изпълнение на копие на P или Q и т.н.
Обосновете отговора си.
- Използваме семафорите t1 и t2 и ги инициализираме така:
sempahore t1, t2
t1.init(1)
t2.init(0)

Добавяме в кода на процесите P и Q синхронизиращи инструкции:
process P	process Q	process R	process W
t1.wait()	t1.wait()	t2.wait()	t2.wait()
p1		q1		r1		w1
p2		q2		r2		w2
t2.signal()	t2.signal()	t1.signal()	t1.signal()

98. (2020-SE-03) Всеки от процесите P, Q и R изпълнява поредица от три инструкции:
process P 	process Q 	process R
p_1 		q_1 		r_1
p_2 		q_2 		r_2
p_3 		q_3 		r_3
Осигурете чрез семафори синхронизация на P, Q и R така, че да се изпълнят едновременно следните изисквания:
• инструкция p_1 да се изпълни преди q_2 и r_2;
• ако q_2 се изпълни преди r_2, то и q_3 да се изпълни преди r_2;
• ако r_2 се изпълни преди q_2, то и r_3 да се изпълни преди q_2.
Обосновете отговора си.
- Използваме семафора t и го инициализираме така:
semaphore t
t.init(0)

Добавяме в кода на процесите P, Q и R синхронизиращи инструкции:
process P	process Q	process R
p1		q1		r1
t.signal()	t.wait()	t.wait()
p2		q2		r2
p3		q3		r3
		t.signal()	t.signal()

99. (2020-CS-XX) Тройна среща - процесите P, Q и R изпълняват поредица от две инструкции:
process P	process Q	process R
p_1		q_1		r_1
p_2		q_2		r_2
Осигурете чрез семафори синхронизация на P, Q и R, така, че:
а) инструкцията p_1 да се изпълни преди q_2 и r_2
б) инструкцията q_1 да се изпълни преди p_2 и r_2
в) инструкцията r_1 да се изпълни преди p_2 и q_2
- Използваме семафорите t1, t2 и t3 и ги инициализираме така:
semaphore t1, t2, t3
t1.init(0)
t2.init(0)
t3.init(0)

Добавяме в кода на процесите P, Q и R синхронизиращи инструкции:
p1		q1		r1
t1.signal()	t2.signal()	t3.signal()
t2.wait()	t1.wait()	t1.wait()
t2.signal()	t1.signal()	t1.signal()
t3.wait()	t3.wait()	t2.wait()
t3.signal()	t3.signal()	t2.signal()
p2		q2		r2

100. (2019-CS-XX) Всеки от процесите P, Q и R изпълнява поредица от две инструкции:
process P 	process Q 	process R
p_1 		q_1 		r_1
p_2 		q_2 		r_2
Осигурете чрез три семафора синхронизация на P, Q и R така, че отделните инструкции да се изпълнят в следния времеви ред: p_1, q_1, r_1, p_2, q_2, r_2

Използваме семафорите t1, t2 и t3 и ги инициализираме така:
semaphore t1, t2, t3
t1.init(1)
t2.init(0)
t3.init(0)

Добавяме в кода на процесите P, Q и R синхронизиращи инструкции:
process P	process Q	process R
t1.wait()	t2.wait()	t3.wait()
p1		q1		r1
t2.signal()	t3.signal()	t1.signal()
t1.wait()	t2.wait()	t3.wait()
p2		q2		r2
t2.signal()	t3.signal()