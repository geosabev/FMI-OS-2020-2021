Документация на решенията на Домашна работа 1, ОС 2020/2021, Факултетен номер 62380

Задача 1.
Основната част от решението на първа задача се основава върху употребата на командата grep (в моя случай egrep) за различни регулярни изрази.

След като разгледах съдържанието на изхода на командата curl за всяка от посочените страници във файла urls, забелязах няколко важни неща, общи за всички страници:
	1. Датата на състезанията доста често не отговаря на формата DD.MM.YYYY, а на D.MM.YYYY, следователно при взимането на датата ще трябва при необходимост да се добави една допълнителна 0 отпред.
	2. Категориите винаги са представени по един и същ начин - <категория><th><категория>, което ще улесни тяхното откриване в последствие.
	3. Всеки ред, съдържащ данни за даден участник, съдържа "Resline C.", където . е дадена латинска буква.
	4. Всеки вид данни, отнасящи се за представянето на даден участник се намират след конкретен клас - pl, name, clb (или club на някои места), runT (или Mark1 runT на места) и т.н.
		4.1. Интересен случай се откроява при имената на участниците, тъй като на места те са хипервръзки, а на други не са, което може да доведе до допълнителна част от низа, която трябва да бъде премахната за коректно взимане на данните. (Тази ситуация аз решавам с една допълнителна променлива i, която в зависимост от това дали има връзка, или не получава стойност 0 или 1, която има отношение при използването на командата cut за взимане на правилната колона.)
	5. Друга характерна особеност е "представянето" на празния низ - "&nbsp;", който се среща в някои колони (DOK и Call например) и трябва да бъде преобразуван до истински празен низ ("").

След като обособихме основните моменти, за които трябва да се внимава в решението, накратко за стъпките в него:
	1. Скриптът започва с кратка "валидация" на входните данни.
		1.1. Проверка за правилен брой на аргументите, подадени на скрипта - трябва да бъде един аргумент, при грешни данни exit-вам със статус 1.
		1.2. Проверка за вида на подадения аргумент - трябва да бъде файл, при грешни данни exit-вам със статус 2.
	2. Същинската част от решението започва с прочитане съдържанието на подадения файл ред по ред.
		2.1. При срещане на начален символ '#', редът се пропуска.
		2.2. В противен случай започва обработката на информацията в изхода на командата curl за конкретния линк.
	3. Първо взимаме датата на състезанието като внимаваме за спазването на желания формат - DD.MM.YYYY.
	4. След това започваме ред по ред да обработваме съдържанието на изхода на командата curl за текущия линк.
		4.1. Взимаме категорията.
		4.2. За да се справя с проблема с разликата в номерата на колоната при имената (наличието на хипервръзка при някои и липсата на такава при други), проверявам дали редът съдържа ключовото "href" и по този начин определям стойността на променливата i, която участва в аритметиката на командата cut, с която взимам имената на участниците, след което с командата sed ги "завъртам", за да придобият правилния формат "Име Фамилия".
 		4.3. Мястото, позивната, броя предаватели, времето и стартовия номер взимам по абсолютно идентичен начин - спрямо позицията на техния открояващ клас.
		4.4. При DOK, трябва да се вземе под внимание различното наименование на класа в различните линкове - на места е clb, на други club. Това решавам в регулярния израз, по който търся информацията. Същата ситуаиця се появява и при колоната за времето, защото на места е runT, а на други - Mark1 runT.
		4.5. При стойност "&nbsp;" за позивната или броя на предавателите, променям тази стойност на "".
	5. Накрая, при събрани стойности за всяка колона, просто ги извеждам с командата echo.

P.S. Тъй като в последствие стана ясно, че в някои линкове редът за участници не е отбелязан с ResLine C., а с ComLine C., където и подредбата не е същата като при тези с ResLine (няма класове като pl, name, и т.н.), трябваше там да подходя по-скоро малко по-аритметично като преброя на коя колона се пада да бъде информацията и съответно да я променям с i-то, както и при другите.

Задача 2.
Втората задача е със сравинтелно по-кратко решение от това на първата.

Стъпките в решението на 2. задача:
	1. Започвам отново с валидация на данните. Тук тя е малко по-разпокъсана от колкото при първа задача, защото в зависимост от различните подкоманди се изискват различни на брой и вид аргументи.
	2. Първа подкоманда: top_places
		2.1. Тук валидацията се изразява в това, дали вторият аргумент е името на командата, дали броят на аргументите е 5, дали категорията е валидна и дали са подадени две числа, отговарящи на условието.
		2.2. Взимам с командата egrep само тези участници, които са участвали в категорията, посочена като аргумент, но ВАЖНО УСЛОВИЕ тук е да бъдат с валидна позиция в класирането, тъй като по условие на задачата валидна позиция е само числена стойност (DSQ, - и т.н. са невалидни и не участват в списъка).
		2.3. Ред по ред проверяваме дали конкретната позиция, на която участникът е завършил в дадено състезание, е най-малко тази, посочена като аргумент на скрипта и ако е изпълнено това условие, взимаме реда.
		2.4. Полученият списък от цикъла while pipe-вам към още няколко команди, с които постепенно извличам резултата.
			2.4.1. Взимам само имената.
			2.4.2. Сортирам ги.
			2.4.3. С командата uniq взимам броя повторения.
			2.4.4. Сортирам новополучения списък в низходящ ред числено и с командата head взимам толкова редове, колкото са ми необходими.
	3. Втора подкоманда: parts
		3.1. Валидацията тук - дали вторият аргумент е именто на командата, дали броят на аргументите е 3 и дали е подадена комбинация от латински букви за име.
		3.2. Тук отново с grep отделям само тези редове, които са ми необходими - в случая само редовете, в които присъства името на участника, който ни интересува.
		3.3. След като получа списък с категориите, в които е участвал търсеният участник, с един цикъл откривам и датите, на които този участник е участвал в конкретната категория.
		3.4. Сортирам датата първо по година, после по месец и накрая по ден.
		3.5. Махам новите редове на датите и ги заменям със запетаи, които в последствие заменям с низа ", ". За да премахна последната запетая, просто използвам командата head, с която махам последните два символа от всеки ред.

