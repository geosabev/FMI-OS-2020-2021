Документация на решениeто на Домашна работа 2, ОС 2020/2021, Факултетен номер 62380

Решението на задачата започва с проста валидация на входните данни - броят на подадените на програмата аргументи да бъде правилен. Допълнителна
валидация се извършва поетапно по време на решението, тъй като тя се различава в дадени случаи.

Структурите start и stop от типа timeval използвам за прецизно изчисление на execution time в различни етапи на решението. (*1)

В общи линии почти цялото тяло на main функцията е заето от if-а, в който според вида на подадения "втори" аргумент
(argv[2], което е типът на работа на програмата) се извършват различни операции.

Въвел съм и трето условие (нещо като валидация на данните) на if - ако посоченият низ не е нито "record",
нито "replay", то отново подадените входни данни са невалидни и се прекратява изпълнението.

Сега ще разгледам поотделно двете т.нар. подточки на решението: частта за record и частта за replay.
1. record
    1.1. Започвам с отваряне на файла, в който ще записваме получената информация. Тук искам да отбележа, че тъй като в условието
не е напълно изрично посочено дали файлът трябва да е вече съществуващ или не, съм включил и флага O_CREAT, който при несъществуващ файл
създава такъв. След това правя проверка за това дали е имало проблеми при отварянето с validateOpen(). Това е една от трите функции,
които позлвам за валидация на отваряне, писане, четене - validateOpen(), validateWrite(), validateRead() (заб. 1).
    1.2. Променливата type използвам за определяне на типа на текущите съобщения, а rMain използвам за последваща валидация.
    1.3. Прочитането на данните от файлов дескриптор 0 (този на stdin), протича в цъкъла while, който е отново е разделен на две части - ако
имам стойност за променливата type = 0x0001 (съобщение state) и ако имам стойност = 0x0002 (съобщение slot_text).
        1.3.1. type == 0x0001 (state)
            1.3.1.1. При съобщение за състояние данните, които получаваме са следните: идентификатор на типа данни (променливата type, която вече
сме прочели), активни слотове за филийки (получаваме ги под формата на битова маска, която прочитаме и записваме в променливата bit_mask от типа uint_16t) и
температура на тостера (тъй като е 4 байта и пише, че е умножена по 100, съм решил да я записвам в променлива от тип int - tempK).
            1.3.1.2. Прочитам стойностите на двете променливи, които все още нямам записани - bit_mask и tempK.
            1.3.1.3. С цел най-малки разлики/закъснения във времето съм сложил взимането на времето stop преди валидацията за правилно прочетени данни с функцията validateRead().
            1.3.1.4. Правя необходимите преобразувания на времето.
            1.3.1.5. Записвам 3-те получени от тостера данни, както и изминалите милисекунди (както се иска в условието).
            1.3.1.6. Валидирам за правилно записани данни с validateWrite().
            1.3.1.7. Преобразувам температурата в целзий.
            1.3.1.8. Първата част от желания изход на stderr е лесна за принтиране. При втората е необходима работа с получената битова маска.
            1.3.1.9. Извеждането на съобщенията към stderr съм извадил в две функции - printState() и printSlotText(). (заб. 2)
        1.3.2. type == 0x0002 (slot_text)
            1.3.2.1. Тук данните, които получаваме са: идентификатор на типа данни (type - вече прочетена), идентификатор на слота (1 байт - следователно
използвам типа uint_8t, променливата е id) и текстът на съобщението (char[13] заради \0 - променливата text).
            1.3.2.2. Прочитам двете променливи, които все още не съм - id и text.
            1.3.2.3. Тук отново валидацията е след взимането на stop времето.
            1.3.2.4. Преобразувам времето.
            1.3.2.5. Записвам данните във файла и валидирам записването с validateWrite.
            1.3.2.6. Извеждам на stderr желаното съобщение.

2. replay - В голяма част тук стъпките в решението се припокриват с тези от частта за "record".
Все пак има няколко интересни и важни момента, които трябва да бъдат разгледани.
    2.1. Флаговете на open() при отваряне са различни - O_RDONLY.
    2.2. Тук се добавя още една променлива - previous, която ще използвам за възстановяване на данните от предходните съобщения.
    2.3. Файловите дескриптори, които се подават на read() и write() тук вече не са 0 (stdin) за read() и fileDescriptor за write(), а
са fileDescriptor за read() и 1 (stdout) за write().
    2.4. Тук за разлика от при record времето (ms) не се записва с write(), тъй като изходът (stdout) от replay е абсолютно същият, като входа (stdin) на съответния record.
Той не съдържа времена. Тези времена ги използваме по-скоро, за правим "изчаквания" между съобщенията, които извеждаме (stdout) и изписваме (stderr).
    2.5. Мястото на моментът, в който се отчита stop времето, е сменено - трябва да е след sleep, защото иначе ще се получи изместване на моментите с 1 позиция напред.

Източници:
1. Използването на gettimeofday() за изчисление на execution time: https://www.techiedelight.com/find-execution-time-c-program/

Забележки:
1. На места в кода при употреба на функциите validateRead() и validateWrite() съм подавал аргументи от вида на 0-1. Това е защото исках да изнеса валидацията
във външни функции с цел да намаля повторението на код, но тъй като на места се налага валидация на 3, а на други на 4 броя данни, предпочетох да действам с
тези фиктивни 1-ци и 0-ли вместо да пиша функции за всяка ситуация - първоначално исках да използвам default стойности за функцията, но в последствие разбрах,
че това не съществува като вариант.
2. В последстиве се замислих дали всички тези функции, "отделени" от main-а, няма да доведат до известно забавяне (копиране на променливи и т.н.), но взимайки под внимание предоставената
таблица в Мудъл за това до каква степен е допустим time jitter, забелязах, че резултатите при мен се вписват съвсем нормално в тази таблица, така че реших да ги оставя така с
цел по-чист код и по-малко повторение на код.
